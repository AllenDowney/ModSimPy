{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ModSimPy Documentation","text":"<p>This is the documentation for the Modeling and Simulation in Python library.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository - Source code and issues</li> <li>Online Book - The full textbook</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#modsim.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>SettableNamespace</code></p> <p>Contains system parameters and their values.</p> <p>Takes keyword arguments and stores them as attributes.</p> Source code in <code>modsim/modsim.py</code> <pre><code>class Params(SettableNamespace):\n    \"\"\"Contains system parameters and their values.\n\n    Takes keyword arguments and stores them as attributes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#modsim.SettableNamespace","title":"<code>SettableNamespace</code>","text":"<p>               Bases: <code>SimpleNamespace</code></p> <p>Contains a collection of parameters.</p> <p>Used to make a System object.</p> <p>Takes keyword arguments and stores them as attributes.</p> Source code in <code>modsim/modsim.py</code> <pre><code>class SettableNamespace(SimpleNamespace):\n    \"\"\"Contains a collection of parameters.\n\n    Used to make a System object.\n\n    Takes keyword arguments and stores them as attributes.\n    \"\"\"\n    def __init__(self, namespace=None, **kwargs):\n        \"\"\"Initialize a SettableNamespace.\n\n        Args:\n            namespace (SettableNamespace, optional): Namespace to copy. Defaults to None.\n            **kwargs: Keyword arguments to store as attributes.\n        \"\"\"\n        super().__init__()\n        if namespace:\n            self.__dict__.update(namespace.__dict__)\n        self.__dict__.update(kwargs)\n\n    def get(self, name, default=None):\n        \"\"\"Look up a variable.\n\n        Args:\n            name (str): Name of the variable to look up.\n            default (any, optional): Value returned if `name` is not present. Defaults to None.\n\n        Returns:\n            any: Value of the variable or default.\n        \"\"\"\n        try:\n            return self.__getattribute__(name, default)\n        except AttributeError:\n            return default\n\n    def set(self, **variables):\n        \"\"\"Make a copy and update the given variables.\n\n        Args:\n            **variables: Keyword arguments to update.\n\n        Returns:\n            Params: New Params object with updated variables.\n        \"\"\"\n        new = copy(self)\n        new.__dict__.update(variables)\n        return new\n</code></pre>"},{"location":"#modsim.SettableNamespace.__init__","title":"<code>__init__(namespace=None, **kwargs)</code>","text":"<p>Initialize a SettableNamespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>SettableNamespace</code> <p>Namespace to copy. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments to store as attributes.</p> <code>{}</code> Source code in <code>modsim/modsim.py</code> <pre><code>def __init__(self, namespace=None, **kwargs):\n    \"\"\"Initialize a SettableNamespace.\n\n    Args:\n        namespace (SettableNamespace, optional): Namespace to copy. Defaults to None.\n        **kwargs: Keyword arguments to store as attributes.\n    \"\"\"\n    super().__init__()\n    if namespace:\n        self.__dict__.update(namespace.__dict__)\n    self.__dict__.update(kwargs)\n</code></pre>"},{"location":"#modsim.SettableNamespace.get","title":"<code>get(name, default=None)</code>","text":"<p>Look up a variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the variable to look up.</p> required <code>default</code> <code>any</code> <p>Value returned if <code>name</code> is not present. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>any</code> <p>Value of the variable or default.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def get(self, name, default=None):\n    \"\"\"Look up a variable.\n\n    Args:\n        name (str): Name of the variable to look up.\n        default (any, optional): Value returned if `name` is not present. Defaults to None.\n\n    Returns:\n        any: Value of the variable or default.\n    \"\"\"\n    try:\n        return self.__getattribute__(name, default)\n    except AttributeError:\n        return default\n</code></pre>"},{"location":"#modsim.SettableNamespace.set","title":"<code>set(**variables)</code>","text":"<p>Make a copy and update the given variables.</p> <p>Parameters:</p> Name Type Description Default <code>**variables</code> <p>Keyword arguments to update.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Params</code> <p>New Params object with updated variables.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def set(self, **variables):\n    \"\"\"Make a copy and update the given variables.\n\n    Args:\n        **variables: Keyword arguments to update.\n\n    Returns:\n        Params: New Params object with updated variables.\n    \"\"\"\n    new = copy(self)\n    new.__dict__.update(variables)\n    return new\n</code></pre>"},{"location":"#modsim.System","title":"<code>System</code>","text":"<p>               Bases: <code>SettableNamespace</code></p> <p>Contains system parameters and their values.</p> <p>Takes keyword arguments and stores them as attributes.</p> Source code in <code>modsim/modsim.py</code> <pre><code>class System(SettableNamespace):\n    \"\"\"Contains system parameters and their values.\n\n    Takes keyword arguments and stores them as attributes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#modsim.State","title":"<code>State(**variables)</code>","text":"<p>Contains the values of state variables.</p> <p>Parameters:</p> Name Type Description Default <code>**variables</code> <p>Keyword arguments to store as state variables.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Series with the state variables.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def State(**variables):\n    \"\"\"Contains the values of state variables.\n\n    Args:\n        **variables: Keyword arguments to store as state variables.\n\n    Returns:\n        pd.Series: Series with the state variables.\n    \"\"\"\n    return pd.Series(variables, name='state')\n</code></pre>"},{"location":"#modsim.SweepFrame","title":"<code>SweepFrame(*args, **kwargs)</code>","text":"<p>Create a DataFrame that maps from parameter value to SweepSeries.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to pd.DataFrame.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to pd.DataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame indexed by parameter value.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def SweepFrame(*args, **kwargs):\n    \"\"\"Create a DataFrame that maps from parameter value to SweepSeries.\n\n    Args:\n        *args: Arguments passed to pd.DataFrame.\n        **kwargs: Keyword arguments passed to pd.DataFrame.\n\n    Returns:\n        pd.DataFrame: DataFrame indexed by parameter value.\n    \"\"\"\n    underride(kwargs, dtype=float)\n    return pd.DataFrame(*args, **kwargs)\n</code></pre>"},{"location":"#modsim.SweepSeries","title":"<code>SweepSeries(*args, **kwargs)</code>","text":"<p>Make a pd.Series object to store results from a parameter sweep.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to pd.Series.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to pd.Series.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Series with index name 'Parameter' and name 'Metric'.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def SweepSeries(*args, **kwargs):\n    \"\"\"Make a pd.Series object to store results from a parameter sweep.\n\n    Args:\n        *args: Arguments passed to pd.Series.\n        **kwargs: Keyword arguments passed to pd.Series.\n\n    Returns:\n        pd.Series: Series with index name 'Parameter' and name 'Metric'.\n    \"\"\"\n    if args or kwargs:\n        underride(kwargs, dtype=float)\n        series = pd.Series(*args, **kwargs)\n    else:\n        series = pd.Series([], dtype=np.float64)\n\n    series.index.name = 'Parameter'\n    if 'name' not in kwargs:\n        series.name = 'Metric'\n    return series\n</code></pre>"},{"location":"#modsim.TimeFrame","title":"<code>TimeFrame(*args, **kwargs)</code>","text":"<p>Create a DataFrame that maps from time to State.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to pd.DataFrame.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to pd.DataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame indexed by time.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def TimeFrame(*args, **kwargs):\n    \"\"\"Create a DataFrame that maps from time to State.\n\n    Args:\n        *args: Arguments passed to pd.DataFrame.\n        **kwargs: Keyword arguments passed to pd.DataFrame.\n\n    Returns:\n        pd.DataFrame: DataFrame indexed by time.\n    \"\"\"\n    underride(kwargs, dtype=float)\n    return pd.DataFrame(*args, **kwargs)\n</code></pre>"},{"location":"#modsim.TimeSeries","title":"<code>TimeSeries(*args, **kwargs)</code>","text":"<p>Make a pd.Series object to represent a time series.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to pd.Series.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to pd.Series.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Series with index name 'Time' and name 'Quantity'.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def TimeSeries(*args, **kwargs):\n    \"\"\"Make a pd.Series object to represent a time series.\n\n    Args:\n        *args: Arguments passed to pd.Series.\n        **kwargs: Keyword arguments passed to pd.Series.\n\n    Returns:\n        pd.Series: Series with index name 'Time' and name 'Quantity'.\n    \"\"\"\n    if args or kwargs:\n        underride(kwargs, dtype=float)\n        series = pd.Series(*args, **kwargs)\n    else:\n        series = pd.Series([], dtype=float)\n\n    series.index.name = 'Time'\n    if 'name' not in kwargs:\n        series.name = 'Quantity'\n    return series\n</code></pre>"},{"location":"#modsim.Vector","title":"<code>Vector(x, y, z=None, **options)</code>","text":"<p>Create a 2D or 3D vector as a pandas Series.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x component.</p> required <code>y</code> <code>float</code> <p>y component.</p> required <code>z</code> <code>float</code> <p>z component. Defaults to None.</p> <code>None</code> <code>**options</code> <p>Additional keyword arguments for pandas.Series.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Series with keys 'x', 'y', and optionally 'z'.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def Vector(x, y, z=None, **options):\n    \"\"\"Create a 2D or 3D vector as a pandas Series.\n\n    Args:\n        x (float): x component.\n        y (float): y component.\n        z (float, optional): z component. Defaults to None.\n        **options: Additional keyword arguments for pandas.Series.\n\n    Returns:\n        pd.Series: Series with keys 'x', 'y', and optionally 'z'.\n    \"\"\"\n    underride(options, name='component')\n    if z is None:\n        return pd.Series(dict(x=x, y=y), **options)\n    else:\n        return pd.Series(dict(x=x, y=y, z=z), **options)\n</code></pre>"},{"location":"#modsim.animate","title":"<code>animate(results, draw_func, *args, interval=None)</code>","text":"<p>Animate results from a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>TimeFrame</code> <p>Results to animate.</p> required <code>draw_func</code> <code>callable</code> <p>Function that draws state.</p> required <code>*args</code> <p>Additional positional arguments passed to draw_func.</p> <code>()</code> <code>interval</code> <code>float</code> <p>Time between frames in seconds. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If results is not a TimeFrame or draw_func is not callable</p> Source code in <code>modsim/modsim.py</code> <pre><code>def animate(results, draw_func, *args, interval=None):\n    \"\"\"Animate results from a simulation.\n\n    Args:\n        results (TimeFrame): Results to animate.\n        draw_func (callable): Function that draws state.\n        *args: Additional positional arguments passed to draw_func.\n        interval (float, optional): Time between frames in seconds. Defaults to None.\n\n    Raises:\n        ValueError: If results is not a TimeFrame or draw_func is not callable\n    \"\"\"\n    if not isinstance(results, pd.DataFrame):\n        raise ValueError(\"results must be a TimeFrame\")\n    if not callable(draw_func):\n        raise ValueError(\"draw_func must be callable\")\n    plt.figure()\n    try:\n        for t, state in results.iterrows():\n            draw_func(t, state, *args)\n            plt.show()\n            if interval:\n                sleep(interval)\n            clear_output(wait=True)\n        draw_func(t, state, *args)\n        plt.show()\n    except KeyboardInterrupt:\n        pass\n</code></pre>"},{"location":"#modsim.cart2pol","title":"<code>cart2pol(x, y, z=None)</code>","text":"<p>Convert Cartesian coordinates to polar.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>number or sequence</code> <p>x coordinate.</p> required <code>y</code> <code>number or sequence</code> <p>y coordinate.</p> required <code>z</code> <code>number or sequence</code> <p>z coordinate. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(theta, rho) or (theta, rho, z).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x or y are not numeric or array-like, or if z is provided but not numeric or array-like</p> Source code in <code>modsim/modsim.py</code> <pre><code>def cart2pol(x, y, z=None):\n    \"\"\"Convert Cartesian coordinates to polar.\n\n    Args:\n        x (number or sequence): x coordinate.\n        y (number or sequence): y coordinate.\n        z (number or sequence, optional): z coordinate. Defaults to None.\n\n    Returns:\n        tuple: (theta, rho) or (theta, rho, z).\n\n    Raises:\n        ValueError: If x or y are not numeric or array-like, or if z is provided but not numeric or array-like\n    \"\"\"\n    if not isinstance(x, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"x must be numeric or array-like\")\n    if not isinstance(y, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"y must be numeric or array-like\")\n    if z is not None and not isinstance(z, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"z must be numeric or array-like\")\n    x = np.asarray(x)\n    y = np.asarray(y)\n    rho = np.hypot(x, y)\n    theta = np.arctan2(y, x)\n    if z is None:\n        return theta, rho\n    else:\n        return theta, rho, z\n</code></pre>"},{"location":"#modsim.contour","title":"<code>contour(df, **options)</code>","text":"<p>Makes a contour plot from a DataFrame.</p> <p>Wrapper for plt.contour https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.contour.html</p> <p>Note: columns and index must be numerical</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to plot.</p> required <code>**options</code> <p>Additional keyword arguments for plt.contour.</p> <code>{}</code> Source code in <code>modsim/modsim.py</code> <pre><code>def contour(df, **options):\n    \"\"\"Makes a contour plot from a DataFrame.\n\n    Wrapper for plt.contour\n    https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.contour.html\n\n    Note: columns and index must be numerical\n\n    Args:\n        df (pd.DataFrame): DataFrame to plot.\n        **options: Additional keyword arguments for plt.contour.\n    \"\"\"\n    fontsize = options.pop(\"fontsize\", 12)\n    underride(options, cmap=\"viridis\")\n    x = df.columns\n    y = df.index\n    X, Y = np.meshgrid(x, y)\n    cs = plt.contour(X, Y, df, **options)\n    plt.clabel(cs, inline=1, fontsize=fontsize)\n</code></pre>"},{"location":"#modsim.crossings","title":"<code>crossings(series, value)</code>","text":"<p>Find the labels where the series passes through a given value.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series with increasing numerical index.</p> required <code>value</code> <code>float</code> <p>Value to find crossings for.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Array of labels where the series crosses the value.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def crossings(series, value):\n    \"\"\"Find the labels where the series passes through a given value.\n\n    Args:\n        series (pd.Series): Series with increasing numerical index.\n        value (float): Value to find crossings for.\n\n    Returns:\n        np.ndarray: Array of labels where the series crosses the value.\n    \"\"\"\n    values = series.values - value\n    interp = InterpolatedUnivariateSpline(series.index, values)\n    return interp.roots()\n</code></pre>"},{"location":"#modsim.decorate","title":"<code>decorate(**options)</code>","text":"<p>Decorate the current axes.</p> <p>Call decorate with keyword arguments like decorate(title='Title',          xlabel='x',          ylabel='y')</p> <p>The keyword arguments can be any of the axis properties https://matplotlib.org/api/axes_api.html</p> <p>Parameters:</p> Name Type Description Default <code>**options</code> <p>Keyword arguments for axis properties.</p> <code>{}</code> Source code in <code>modsim/modsim.py</code> <pre><code>def decorate(**options):\n    \"\"\"Decorate the current axes.\n\n    Call decorate with keyword arguments like\n    decorate(title='Title',\n             xlabel='x',\n             ylabel='y')\n\n    The keyword arguments can be any of the axis properties\n    https://matplotlib.org/api/axes_api.html\n\n    Args:\n        **options: Keyword arguments for axis properties.\n    \"\"\"\n    ax = plt.gca()\n    ax.set(**options)\n\n    handles, labels = ax.get_legend_handles_labels()\n    if handles:\n        ax.legend(handles, labels)\n\n    plt.tight_layout()\n</code></pre>"},{"location":"#modsim.flip","title":"<code>flip(p=0.5)</code>","text":"<p>Flips a coin with the given probability.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability between 0 and 1.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True or False.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def flip(p=0.5):\n    \"\"\"Flips a coin with the given probability.\n\n    Args:\n        p (float): Probability between 0 and 1.\n\n    Returns:\n        bool: True or False.\n    \"\"\"\n    return np.random.random() &lt; p\n</code></pre>"},{"location":"#modsim.gradient","title":"<code>gradient(series, **options)</code>","text":"<p>Computes the numerical derivative of a series.</p> <p>If the elements of series have units, they are dropped.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object.</p> required <code>**options</code> <p>Additional keyword arguments for np.gradient.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Series with the same subclass as the input.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If series is not a pandas Series</p> Source code in <code>modsim/modsim.py</code> <pre><code>def gradient(series, **options):\n    \"\"\"Computes the numerical derivative of a series.\n\n    If the elements of series have units, they are dropped.\n\n    Args:\n        series (pd.Series): Series object.\n        **options: Additional keyword arguments for np.gradient.\n\n    Returns:\n        pd.Series: Series with the same subclass as the input.\n\n    Raises:\n        ValueError: If series is not a pandas Series\n    \"\"\"\n    if not isinstance(series, pd.Series):\n        raise ValueError(\"series must be a pandas Series\")\n    x = series.index\n    y = series.values\n    a = np.gradient(y, x, **options)\n    return series.__class__(a, series.index)\n</code></pre>"},{"location":"#modsim.has_nan","title":"<code>has_nan(a)</code>","text":"<p>Check whether an array or Series contains any NaNs.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like</code> <p>NumPy array or Pandas Series.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if any NaNs are present, False otherwise.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def has_nan(a):\n    \"\"\"Check whether an array or Series contains any NaNs.\n\n    Args:\n        a (array-like): NumPy array or Pandas Series.\n\n    Returns:\n        bool: True if any NaNs are present, False otherwise.\n    \"\"\"\n    return np.any(np.isnan(a))\n</code></pre>"},{"location":"#modsim.interpolate","title":"<code>interpolate(series, **options)</code>","text":"<p>Create an interpolation function from a Series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object with strictly increasing index.</p> required <code>**options</code> <p>Additional keyword arguments for scipy.interpolate.interp1d.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>callable</code> <p>Function that maps from the index to the values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the index contains NaNs or is not strictly increasing.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def interpolate(series, **options):\n    \"\"\"Create an interpolation function from a Series.\n\n    Args:\n        series (pd.Series): Series object with strictly increasing index.\n        **options: Additional keyword arguments for scipy.interpolate.interp1d.\n\n    Returns:\n        callable: Function that maps from the index to the values.\n\n    Raises:\n        ValueError: If the index contains NaNs or is not strictly increasing.\n    \"\"\"\n    if has_nan(series.index):\n        msg = \"\"\"The Series you passed to interpolate contains\n                 NaN values in the index, which would result in\n                 undefined behavior.  So I'm putting a stop to that.\"\"\"\n        raise ValueError(msg)\n\n    if not is_strictly_increasing(series.index):\n        msg = \"\"\"The Series you passed to interpolate has an index\n                 that is not strictly increasing, which would result in\n                 undefined behavior.  So I'm putting a stop to that.\"\"\"\n        raise ValueError(msg)\n\n    # make the interpolate function extrapolate past the ends of\n    # the range, unless `options` already specifies a value for `fill_value`\n    underride(options, fill_value=\"extrapolate\")\n\n    # call interp1d, which returns a new function object\n    x = series.index\n    y = series.values\n    interp_func = interp1d(x, y, **options)\n    return interp_func\n</code></pre>"},{"location":"#modsim.interpolate_inverse","title":"<code>interpolate_inverse(series, **options)</code>","text":"<p>Interpolate the inverse function of a Series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series representing a mapping from a to b.</p> required <code>**options</code> <p>Additional keyword arguments for scipy.interpolate.interp1d.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>callable</code> <p>Interpolation object, can be used as a function from b to a.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def interpolate_inverse(series, **options):\n    \"\"\"Interpolate the inverse function of a Series.\n\n    Args:\n        series (pd.Series): Series representing a mapping from a to b.\n        **options: Additional keyword arguments for scipy.interpolate.interp1d.\n\n    Returns:\n        callable: Interpolation object, can be used as a function from b to a.\n    \"\"\"\n    inverse = pd.Series(series.index, index=series.values)\n    interp_func = interpolate(inverse, **options)\n    return interp_func\n</code></pre>"},{"location":"#modsim.is_strictly_increasing","title":"<code>is_strictly_increasing(a)</code>","text":"<p>Check whether the elements of an array are strictly increasing.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like</code> <p>NumPy array or Pandas Series.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if strictly increasing, False otherwise.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def is_strictly_increasing(a):\n    \"\"\"Check whether the elements of an array are strictly increasing.\n\n    Args:\n        a (array-like): NumPy array or Pandas Series.\n\n    Returns:\n        bool: True if strictly increasing, False otherwise.\n    \"\"\"\n    return np.all(np.diff(a) &gt; 0)\n</code></pre>"},{"location":"#modsim.leastsq","title":"<code>leastsq(error_func, x0, *args, **options)</code>","text":"<p>Find the parameters that yield the best fit for the data using least squares.</p> <p>Parameters:</p> Name Type Description Default <code>error_func</code> <code>callable</code> <p>Function that computes a sequence of errors.</p> required <code>x0</code> <code>array - like</code> <p>Initial guess for the best parameters.</p> required <code>*args</code> <p>Additional positional arguments passed to error_func.</p> <code>()</code> <code>**options</code> <p>Additional keyword arguments passed to scipy.optimize.leastsq.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(best_params, details) best_params: Best-fit parameters (same type as x0 if possible). details: SimpleNamespace with fit details and success flag.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def leastsq(error_func, x0, *args, **options):\n    \"\"\"Find the parameters that yield the best fit for the data using least squares.\n\n    Args:\n        error_func (callable): Function that computes a sequence of errors.\n        x0 (array-like): Initial guess for the best parameters.\n        *args: Additional positional arguments passed to error_func.\n        **options: Additional keyword arguments passed to scipy.optimize.leastsq.\n\n    Returns:\n        tuple: (best_params, details)\n            best_params: Best-fit parameters (same type as x0 if possible).\n            details: SimpleNamespace with fit details and success flag.\n    \"\"\"\n    # override `full_output` so we get a message if something goes wrong\n    options[\"full_output\"] = True\n\n    # run leastsq\n    t = scipy.optimize.leastsq(error_func, x0=x0, args=args, **options)\n    best_params, cov_x, infodict, mesg, ier = t\n\n    # pack the results into a ModSimSeries object\n    details = SimpleNamespace(cov_x=cov_x,\n                              mesg=mesg,\n                              ier=ier,\n                              **infodict)\n    details.success = details.ier in [1,2,3,4]\n\n    # if we got a Params object, we should return a Params object\n    if isinstance(x0, Params):\n        best_params = Params(pd.Series(best_params, x0.index))\n\n    # return the best parameters and details\n    return best_params, details\n</code></pre>"},{"location":"#modsim.linrange","title":"<code>linrange(start, stop=None, step=1)</code>","text":"<p>Make an array of equally spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>First value.</p> required <code>stop</code> <code>float</code> <p>Last value (might be approximate). Defaults to None.</p> <code>None</code> <code>step</code> <code>float</code> <p>Difference between elements. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>np.ndarray: Array of equally spaced values.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def linrange(start, stop=None, step=1):\n    \"\"\"Make an array of equally spaced values.\n\n    Args:\n        start (float): First value.\n        stop (float, optional): Last value (might be approximate). Defaults to None.\n        step (float, optional): Difference between elements. Defaults to 1.\n\n    Returns:\n        np.ndarray: Array of equally spaced values.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n    n = int(round((stop-start) / step))\n    return linspace(start, stop, n+1)\n</code></pre>"},{"location":"#modsim.magnitude","title":"<code>magnitude(x)</code>","text":"<p>Return the magnitude of a Quantity or number.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>object</code> <p>Quantity or number.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Magnitude as a plain number.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def magnitude(x):\n    \"\"\"Return the magnitude of a Quantity or number.\n\n    Args:\n        x (object): Quantity or number.\n\n    Returns:\n        float: Magnitude as a plain number.\n    \"\"\"\n    return x.magnitude if hasattr(x, 'magnitude') else x\n</code></pre>"},{"location":"#modsim.make_series","title":"<code>make_series(x, y, **options)</code>","text":"<p>Make a Pandas Series.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>sequence</code> <p>Sequence used as the index.</p> required <code>y</code> <code>sequence</code> <p>Sequence used as the values.</p> required <code>**options</code> <p>Additional keyword arguments for pd.Series.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.Series: Pandas Series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x or y are not array-like or have different lengths</p> Source code in <code>modsim/modsim.py</code> <pre><code>def make_series(x, y, **options):\n    \"\"\"Make a Pandas Series.\n\n    Args:\n        x (sequence): Sequence used as the index.\n        y (sequence): Sequence used as the values.\n        **options: Additional keyword arguments for pd.Series.\n\n    Returns:\n        pd.Series: Pandas Series.\n\n    Raises:\n        ValueError: If x or y are not array-like or have different lengths\n    \"\"\"\n    validate_array_like(x, \"x\")\n    validate_array_like(y, \"y\")\n    if len(x) != len(y):\n        raise ValueError(\"x and y must have the same length\")\n    underride(options, name='values')\n    if isinstance(y, pd.Series):\n        y = y.values\n    series = pd.Series(y, index=x, **options)\n    series.index.name = 'index'\n    return series\n</code></pre>"},{"location":"#modsim.maximize_scalar","title":"<code>maximize_scalar(func, *args, **kwargs)</code>","text":"<p>Find the input value that maximizes <code>func</code>.</p> <p>Wrapper for https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to be maximized.</p> required <code>*args</code> <p>Additional positional arguments passed to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>minimize_scalar</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>OptimizeResult</code> <p>Object containing the maximum and optimization details.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the optimization does not succeed.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def maximize_scalar(func, *args, **kwargs):\n    \"\"\"Find the input value that maximizes `func`.\n\n    Wrapper for https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html\n\n    Args:\n        func (callable): Function to be maximized.\n        *args: Additional positional arguments passed to `func`.\n        **kwargs: Additional keyword arguments passed to `minimize_scalar`.\n\n    Returns:\n        OptimizeResult: Object containing the maximum and optimization details.\n\n    Raises:\n        Exception: If the optimization does not succeed.\n    \"\"\"\n    def min_func(*args):\n        return -func(*args)\n\n    underride(kwargs, __func_name='maximize_scalar')\n\n    res = minimize_scalar(min_func, *args, **kwargs)\n\n    # we have to negate the function value before returning res\n    res.fun = -res.fun\n    return res\n</code></pre>"},{"location":"#modsim.minimize_scalar","title":"<code>minimize_scalar(func, *args, **kwargs)</code>","text":"<p>Find the input value that minimizes <code>func</code>.</p> <p>Wrapper for https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to be minimized.</p> required <code>*args</code> <p>Additional positional arguments passed to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>minimize_scalar</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>OptimizeResult</code> <p>Object containing the minimum and optimization details.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the optimization does not succeed.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def minimize_scalar(func, *args, **kwargs):\n    \"\"\"Find the input value that minimizes `func`.\n\n    Wrapper for\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html\n\n    Args:\n        func (callable): Function to be minimized.\n        *args: Additional positional arguments passed to `func`.\n        **kwargs: Additional keyword arguments passed to `minimize_scalar`.\n\n    Returns:\n        OptimizeResult: Object containing the minimum and optimization details.\n\n    Raises:\n        Exception: If the optimization does not succeed.\n    \"\"\"\n    underride(kwargs, __func_name='minimize_scalar')\n\n    method = kwargs.get('method', None)\n    if method is None:\n        method = 'bounded' if kwargs.get('bounds', None) else 'brent'\n        kwargs['method'] = method\n\n    if method == 'bounded':\n        param_name = 'bounds'\n        param_len = [2]\n    else:\n        param_name = 'bracket'\n        param_len = [2, 3]\n\n    func_name = kwargs.pop('__func_name')\n    __check_kwargs(kwargs, param_name, param_len, lambda x: func(x, *args), func_name)\n\n    res = spo.minimize_scalar(func, args=args, **kwargs)\n\n    if not res.success:\n        msg = (\"minimize_scalar did not succeed.\"\n               \"The message it returned is: \\n\" +\n               res.message)\n        raise Exception(msg)\n\n    return res\n</code></pre>"},{"location":"#modsim.plot_segment","title":"<code>plot_segment(A, B, **options)</code>","text":"<p>Plots a line segment between two Vectors.</p> <p>For 3-D vectors, the z axis is ignored.</p> <p>Additional options are passed along to plot().</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vector</code> <p>First vector.</p> required <code>B</code> <code>Vector</code> <p>Second vector.</p> required <code>**options</code> <p>Additional keyword arguments for plt.plot.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If A or B are not Vector objects</p> Source code in <code>modsim/modsim.py</code> <pre><code>def plot_segment(A, B, **options):\n    \"\"\"Plots a line segment between two Vectors.\n\n    For 3-D vectors, the z axis is ignored.\n\n    Additional options are passed along to plot().\n\n    Args:\n        A (Vector): First vector.\n        B (Vector): Second vector.\n        **options: Additional keyword arguments for plt.plot.\n\n    Raises:\n        ValueError: If A or B are not Vector objects\n    \"\"\"\n    if not isinstance(A, pd.Series) or not isinstance(B, pd.Series):\n        raise ValueError(\"A and B must be Vector objects\")\n    xs = A.x, B.x\n    ys = A.y, B.y\n    plt.plot(xs, ys, **options)\n</code></pre>"},{"location":"#modsim.pol2cart","title":"<code>pol2cart(theta, rho, z=None)</code>","text":"<p>Convert polar coordinates to Cartesian.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>number or sequence</code> <p>Angle in radians.</p> required <code>rho</code> <code>number or sequence</code> <p>Radius.</p> required <code>z</code> <code>number or sequence</code> <p>z coordinate. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(x, y) or (x, y, z).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If theta or rho are not numeric or array-like, or if z is provided but not numeric or array-like</p> Source code in <code>modsim/modsim.py</code> <pre><code>def pol2cart(theta, rho, z=None):\n    \"\"\"Convert polar coordinates to Cartesian.\n\n    Args:\n        theta (number or sequence): Angle in radians.\n        rho (number or sequence): Radius.\n        z (number or sequence, optional): z coordinate. Defaults to None.\n\n    Returns:\n        tuple: (x, y) or (x, y, z).\n\n    Raises:\n        ValueError: If theta or rho are not numeric or array-like, or if z is provided but not numeric or array-like\n    \"\"\"\n    if not isinstance(theta, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"theta must be numeric or array-like\")\n    if not isinstance(rho, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"rho must be numeric or array-like\")\n    if z is not None and not isinstance(z, (int, float, list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(\"z must be numeric or array-like\")\n    x = rho * np.cos(theta)\n    y = rho * np.sin(theta)\n    if z is None:\n        return x, y\n    else:\n        return x, y, z\n</code></pre>"},{"location":"#modsim.remove_from_legend","title":"<code>remove_from_legend(bad_labels)</code>","text":"<p>Remove specified labels from the current plot legend.</p> <p>Parameters:</p> Name Type Description Default <code>bad_labels</code> <code>list</code> <p>Sequence of label strings to remove from the legend.</p> required Source code in <code>modsim/modsim.py</code> <pre><code>def remove_from_legend(bad_labels):\n    \"\"\"Remove specified labels from the current plot legend.\n\n    Args:\n        bad_labels (list): Sequence of label strings to remove from the legend.\n    \"\"\"\n    ax = plt.gca()\n    handles, labels = ax.get_legend_handles_labels()\n    handle_list, label_list = [], []\n    for handle, label in zip(handles, labels):\n        if label not in bad_labels:\n            handle_list.append(handle)\n            label_list.append(label)\n    ax.legend(handle_list, label_list)\n</code></pre>"},{"location":"#modsim.remove_units","title":"<code>remove_units(namespace)</code>","text":"<p>Remove units from the values in a Namespace (top-level only).</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>object</code> <p>Namespace with attributes.</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>New Namespace object with units removed from values.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def remove_units(namespace):\n    \"\"\"Remove units from the values in a Namespace (top-level only).\n\n    Args:\n        namespace (object): Namespace with attributes.\n\n    Returns:\n        object: New Namespace object with units removed from values.\n    \"\"\"\n    res = copy(namespace)\n    for label, value in res.__dict__.items():\n        if isinstance(value, pd.Series):\n            value = remove_units_series(value)\n        res.__dict__[label] = magnitude(value)\n    return res\n</code></pre>"},{"location":"#modsim.remove_units_series","title":"<code>remove_units_series(series)</code>","text":"<p>Remove units from the values in a Series (top-level only).</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series with possible units.</p> required <p>Returns:</p> Type Description <p>pd.Series: New Series object with units removed from values.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def remove_units_series(series):\n    \"\"\"Remove units from the values in a Series (top-level only).\n\n    Args:\n        series (pd.Series): Series with possible units.\n\n    Returns:\n        pd.Series: New Series object with units removed from values.\n    \"\"\"\n    res = copy(series)\n    for label, value in res.items():\n        res[label] = magnitude(value)\n    return res\n</code></pre>"},{"location":"#modsim.root_scalar","title":"<code>root_scalar(func, *args, **kwargs)</code>","text":"<p>Find the input value that is a root of <code>func</code>.</p> <p>Wrapper for https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root_scalar.html</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to find a root of.</p> required <code>*args</code> <p>Additional positional arguments passed to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>root_scalar</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RootResults</code> <p>Object containing the root and convergence information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the solver does not converge.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def root_scalar(func, *args, **kwargs):\n    \"\"\"Find the input value that is a root of `func`.\n\n    Wrapper for\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root_scalar.html\n\n    Args:\n        func (callable): Function to find a root of.\n        *args: Additional positional arguments passed to `func`.\n        **kwargs: Additional keyword arguments passed to `root_scalar`.\n\n    Returns:\n        RootResults: Object containing the root and convergence information.\n\n    Raises:\n        ValueError: If the solver does not converge.\n    \"\"\"\n    underride(kwargs, rtol=1e-4)\n\n    __check_kwargs(kwargs, 'bracket', [2], lambda x: func(x, *args), 'root_scalar')\n\n    res = spo.root_scalar(func, *args, **kwargs)\n\n    if not res.converged:\n        msg = (\"scipy.optimize.root_scalar did not converge. \"\n               \"The message it returned is:\\n\" + res.flag)\n        raise ValueError(msg)\n\n    return res\n</code></pre>"},{"location":"#modsim.run_solve_ivp","title":"<code>run_solve_ivp(system, slope_func, **options)</code>","text":"<p>Compute a numerical solution to a differential equation using solve_ivp.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>System object containing 'init', 't_end', and optionally 't_0'.</p> required <code>slope_func</code> <code>callable</code> <p>Function that computes slopes.</p> required <code>**options</code> <p>Additional keyword arguments for scipy.integrate.solve_ivp.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(TimeFrame of results, details from solve_ivp)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required system attributes are missing or if the solver fails.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def run_solve_ivp(system, slope_func, **options):\n    \"\"\"Compute a numerical solution to a differential equation using solve_ivp.\n\n    Args:\n        system (System): System object containing 'init', 't_end', and optionally 't_0'.\n        slope_func (callable): Function that computes slopes.\n        **options: Additional keyword arguments for scipy.integrate.solve_ivp.\n\n    Returns:\n        tuple: (TimeFrame of results, details from solve_ivp)\n\n    Raises:\n        ValueError: If required system attributes are missing or if the solver fails.\n    \"\"\"\n    system = remove_units(system)\n\n    # make sure `system` contains `init`\n    if not hasattr(system, \"init\"):\n        msg = \"\"\"It looks like `system` does not contain `init`\n                 as a system variable.  `init` should be a State\n                 object that specifies the initial condition:\"\"\"\n        raise ValueError(msg)\n\n    # make sure `system` contains `t_end`\n    if not hasattr(system, \"t_end\"):\n        msg = \"\"\"It looks like `system` does not contain `t_end`\n                 as a system variable.  `t_end` should be the\n                 final time:\"\"\"\n        raise ValueError(msg)\n\n    # the default value for t_0 is 0\n    t_0 = getattr(system, \"t_0\", 0)\n\n    # try running the slope function with the initial conditions\n    try:\n        slope_func(t_0, system.init, system)\n    except Exception as e:\n        msg = \"\"\"Before running scipy.integrate.solve_ivp, I tried\n                 running the slope function you provided with the\n                 initial conditions in `system` and `t=t_0` and I got\n                 the following error:\"\"\"\n        logger.error(msg)\n        raise (e)\n\n    # get the list of event functions\n    events = options.get('events', [])\n\n    # if there's only one event function, put it in a list\n    try:\n        iter(events)\n    except TypeError:\n        events = [events]\n\n    for event_func in events:\n        # make events terminal unless otherwise specified\n        if not hasattr(event_func, 'terminal'):\n            event_func.terminal = True\n\n        # test the event function with the initial conditions\n        try:\n            event_func(t_0, system.init, system)\n        except Exception as e:\n            msg = \"\"\"Before running scipy.integrate.solve_ivp, I tried\n                     running the event function you provided with the\n                     initial conditions in `system` and `t=t_0` and I got\n                     the following error:\"\"\"\n            logger.error(msg)\n            raise (e)\n\n    # get dense output unless otherwise specified\n    if not 't_eval' in options:\n        underride(options, dense_output=True)\n\n    # run the solver\n    bunch = solve_ivp(slope_func, [t_0, system.t_end], system.init,\n                      args=[system], **options)\n\n    # separate the results from the details\n    y = bunch.pop(\"y\")\n    t = bunch.pop(\"t\")\n\n    # get the column names from `init`, if possible\n    if hasattr(system.init, 'index'):\n        columns = system.init.index\n    else:\n        columns = range(len(system.init))\n\n    # evaluate the results at equally-spaced points\n    if options.get('dense_output', False):\n        try:\n            num = system.num\n        except AttributeError:\n            num = 101\n        t_final = t[-1]\n        t_array = linspace(t_0, t_final, num)\n        y_array = bunch.sol(t_array)\n\n        # pack the results into a TimeFrame\n        results = TimeFrame(y_array.T, index=t_array,\n                        columns=columns)\n    else:\n        results = TimeFrame(y.T, index=t,\n                        columns=columns)\n\n    return results, bunch\n</code></pre>"},{"location":"#modsim.savefig","title":"<code>savefig(filename, **options)</code>","text":"<p>Save the current figure.</p> <p>Keyword arguments are passed along to plt.savefig</p> <p>https://matplotlib.org/api/_as_gen/matplotlib.pyplot.savefig.html</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file to save the figure to.</p> required <code>**options</code> <p>Additional keyword arguments for plt.savefig.</p> <code>{}</code> Source code in <code>modsim/modsim.py</code> <pre><code>def savefig(filename, **options):\n    \"\"\"Save the current figure.\n\n    Keyword arguments are passed along to plt.savefig\n\n    https://matplotlib.org/api/_as_gen/matplotlib.pyplot.savefig.html\n\n    Args:\n        filename (str): Name of the file to save the figure to.\n        **options: Additional keyword arguments for plt.savefig.\n    \"\"\"\n    print(\"Saving figure to file\", filename)\n    plt.savefig(filename, **options)\n</code></pre>"},{"location":"#modsim.scalar_proj","title":"<code>scalar_proj(v, w)</code>","text":"<p>Returns the scalar projection of v onto w.</p> <p>Which is the magnitude of the projection of v onto w.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector to project.</p> required <code>w</code> <code>array - like</code> <p>Vector to project onto.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Scalar projection of v onto w.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def scalar_proj(v, w):\n    \"\"\"Returns the scalar projection of v onto w.\n\n    Which is the magnitude of the projection of v onto w.\n\n    Args:\n        v (array-like): Vector to project.\n        w (array-like): Vector to project onto.\n\n    Returns:\n        float: Scalar projection of v onto w.\n    \"\"\"\n    return vector_dot(v, vector_hat(w))\n</code></pre>"},{"location":"#modsim.show","title":"<code>show(obj)</code>","text":"<p>Display a Series or Namespace as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>Series or Namespace to display.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame representation of the object.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def show(obj):\n    \"\"\"Display a Series or Namespace as a DataFrame.\n\n    Args:\n        obj (object): Series or Namespace to display.\n\n    Returns:\n        pd.DataFrame: DataFrame representation of the object.\n    \"\"\"\n    if isinstance(obj, pd.Series):\n        df = pd.DataFrame(obj)\n        return df\n    elif hasattr(obj, '__dict__'):\n        return pd.DataFrame(pd.Series(obj.__dict__),\n                            columns=['value'])\n    else:\n        return obj\n</code></pre>"},{"location":"#modsim.source_code","title":"<code>source_code(obj)</code>","text":"<p>Print the source code for a given object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>Function or method object to print source for.</p> required Source code in <code>modsim/modsim.py</code> <pre><code>def source_code(obj):\n    \"\"\"Print the source code for a given object.\n\n    Args:\n        obj (object): Function or method object to print source for.\n    \"\"\"\n    print(inspect.getsource(obj))\n</code></pre>"},{"location":"#modsim.underride","title":"<code>underride(d, **options)</code>","text":"<p>Add key-value pairs to d only if key is not in d.</p> <p>If d is None, create a new dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary to update.</p> required <code>**options</code> <p>Keyword arguments to add to d.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Updated dictionary.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def underride(d, **options):\n    \"\"\"Add key-value pairs to d only if key is not in d.\n\n    If d is None, create a new dictionary.\n\n    Args:\n        d (dict): Dictionary to update.\n        **options: Keyword arguments to add to d.\n\n    Returns:\n        dict: Updated dictionary.\n    \"\"\"\n    if d is None:\n        d = {}\n\n    for key, val in options.items():\n        d.setdefault(key, val)\n\n    return d\n</code></pre>"},{"location":"#modsim.validate_array_like","title":"<code>validate_array_like(value, name)</code>","text":"<p>Validate that a value is array-like.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def validate_array_like(value, name):\n    \"\"\"Validate that a value is array-like.\"\"\"\n    if not isinstance(value, (list, tuple, np.ndarray, pd.Series)):\n        raise ValueError(f\"{name} must be array-like, got {type(value)}\")\n</code></pre>"},{"location":"#modsim.validate_numeric","title":"<code>validate_numeric(value, name)</code>","text":"<p>Validate that a value is numeric.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def validate_numeric(value, name):\n    \"\"\"Validate that a value is numeric.\"\"\"\n    if not isinstance(value, (int, float)):\n        raise ValueError(f\"{name} must be numeric, got {type(value)}\")\n</code></pre>"},{"location":"#modsim.validate_positive","title":"<code>validate_positive(value, name)</code>","text":"<p>Validate that a value is positive.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def validate_positive(value, name):\n    \"\"\"Validate that a value is positive.\"\"\"\n    if value &lt;= 0:\n        raise ValueError(f\"{name} must be positive, got {value}\")\n</code></pre>"},{"location":"#modsim.vector_angle","title":"<code>vector_angle(v)</code>","text":"<p>Angle between v and the positive x axis.</p> <p>Only works with 2-D vectors.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>2-D vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Angle in radians.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like or is not 2D</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_angle(v):\n    \"\"\"Angle between v and the positive x axis.\n\n    Only works with 2-D vectors.\n\n    Args:\n        v (array-like): 2-D vector.\n\n    Returns:\n        float: Angle in radians.\n\n    Raises:\n        ValueError: If v is not array-like or is not 2D\n    \"\"\"\n    validate_array_like(v, \"v\")\n    if len(v) != 2:\n        raise ValueError(\"vector_angle only works with 2D vectors\")\n    x, y = v\n    return np.arctan2(y, x)\n</code></pre>"},{"location":"#modsim.vector_cross","title":"<code>vector_cross(v, w)</code>","text":"<p>Cross product of v and w.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>First vector.</p> required <code>w</code> <code>array - like</code> <p>Second vector.</p> required <p>Returns:</p> Type Description <p>array-like: Cross product of v and w.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v or w are not array-like, or not both 2D or 3D, or not same length</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_cross(v, w):\n    \"\"\"Cross product of v and w.\n\n    Args:\n        v (array-like): First vector.\n        w (array-like): Second vector.\n\n    Returns:\n        array-like: Cross product of v and w.\n\n    Raises:\n        ValueError: If v or w are not array-like, or not both 2D or 3D, or not same length\n    \"\"\"\n    validate_array_like(v, \"v\")\n    validate_array_like(w, \"w\")\n    if len(v) != len(w):\n        raise ValueError(\"Vectors must have the same length for cross product\")\n    if len(v) not in (2, 3):\n        raise ValueError(\"Cross product only defined for 2D or 3D vectors\")\n    res = np.cross(v, w)\n    if len(v) == 3:\n        return Vector(*res)\n    else:\n        return res\n</code></pre>"},{"location":"#modsim.vector_diff_angle","title":"<code>vector_diff_angle(v, w)</code>","text":"<p>Angular difference between two vectors, in radians.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>First vector.</p> required <code>w</code> <code>array - like</code> <p>Second vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Angular difference in radians.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v or w are not array-like or not same length</p> <code>NotImplementedError</code> <p>If the vectors are not 2-D.</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_diff_angle(v, w):\n    \"\"\"Angular difference between two vectors, in radians.\n\n    Args:\n        v (array-like): First vector.\n        w (array-like): Second vector.\n\n    Returns:\n        float: Angular difference in radians.\n\n    Raises:\n        ValueError: If v or w are not array-like or not same length\n        NotImplementedError: If the vectors are not 2-D.\n    \"\"\"\n    validate_array_like(v, \"v\")\n    validate_array_like(w, \"w\")\n    if len(v) != len(w):\n        raise ValueError(\"Vectors must have the same length for angle difference\")\n    if len(v) == 2:\n        return vector_angle(v) - vector_angle(w)\n    else:\n        # TODO: see http://www.euclideanspace.com/maths/algebra/\n        # vectors/angleBetween/\n        raise NotImplementedError()\n</code></pre>"},{"location":"#modsim.vector_dist","title":"<code>vector_dist(v, w)</code>","text":"<p>Euclidean distance from v to w, with units.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>First vector.</p> required <code>w</code> <code>array - like</code> <p>Second vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Euclidean distance from v to w.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v or w are not array-like or not same length</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_dist(v, w):\n    \"\"\"Euclidean distance from v to w, with units.\n\n    Args:\n        v (array-like): First vector.\n        w (array-like): Second vector.\n\n    Returns:\n        float: Euclidean distance from v to w.\n\n    Raises:\n        ValueError: If v or w are not array-like or not same length\n    \"\"\"\n    validate_array_like(v, \"v\")\n    validate_array_like(w, \"w\")\n    if len(v) != len(w):\n        raise ValueError(\"Vectors must have the same length for distance calculation\")\n    if isinstance(v, list):\n        v = np.asarray(v)\n    return vector_mag(v - w)\n</code></pre>"},{"location":"#modsim.vector_dot","title":"<code>vector_dot(v, w)</code>","text":"<p>Dot product of v and w.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>First vector.</p> required <code>w</code> <code>array - like</code> <p>Second vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Dot product of v and w.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v or w are not array-like or have different lengths</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_dot(v, w):\n    \"\"\"Dot product of v and w.\n\n    Args:\n        v (array-like): First vector.\n        w (array-like): Second vector.\n\n    Returns:\n        float: Dot product of v and w.\n\n    Raises:\n        ValueError: If v or w are not array-like or have different lengths\n    \"\"\"\n    validate_array_like(v, \"v\")\n    validate_array_like(w, \"w\")\n    if len(v) != len(w):\n        raise ValueError(\"Vectors must have the same length\")\n    return np.dot(v, w)\n</code></pre>"},{"location":"#modsim.vector_hat","title":"<code>vector_hat(v)</code>","text":"<p>Unit vector in the direction of v.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector.</p> required <p>Returns:</p> Type Description <p>array-like: Unit vector in the direction of v.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_hat(v):\n    \"\"\"Unit vector in the direction of v.\n\n    Args:\n        v (array-like): Vector.\n\n    Returns:\n        array-like: Unit vector in the direction of v.\n\n    Raises:\n        ValueError: If v is not array-like\n    \"\"\"\n    validate_array_like(v, \"v\")\n    # check if the magnitude of the Quantity is 0\n    mag = vector_mag(v)\n    if mag == 0:\n        return v\n    else:\n        return v / mag\n</code></pre>"},{"location":"#modsim.vector_mag","title":"<code>vector_mag(v)</code>","text":"<p>Vector magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Magnitude of the vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like or is empty</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_mag(v):\n    \"\"\"Vector magnitude.\n\n    Args:\n        v (array-like): Vector.\n\n    Returns:\n        float: Magnitude of the vector.\n\n    Raises:\n        ValueError: If v is not array-like or is empty\n    \"\"\"\n    validate_array_like(v, \"v\")\n    if len(v) == 0:\n        raise ValueError(\"Vector cannot be empty\")\n    return np.sqrt(np.dot(v, v))\n</code></pre>"},{"location":"#modsim.vector_mag2","title":"<code>vector_mag2(v)</code>","text":"<p>Vector magnitude squared.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Magnitude squared of the vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like or is empty</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_mag2(v):\n    \"\"\"Vector magnitude squared.\n\n    Args:\n        v (array-like): Vector.\n\n    Returns:\n        float: Magnitude squared of the vector.\n\n    Raises:\n        ValueError: If v is not array-like or is empty\n    \"\"\"\n    validate_array_like(v, \"v\")\n    if len(v) == 0:\n        raise ValueError(\"Vector cannot be empty\")\n    return np.dot(v, v)\n</code></pre>"},{"location":"#modsim.vector_perp","title":"<code>vector_perp(v)</code>","text":"<p>Perpendicular Vector (rotated left).</p> <p>Only works with 2-D Vectors.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>2-D vector.</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <p>Perpendicular vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like or is not 2D</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_perp(v):\n    \"\"\"Perpendicular Vector (rotated left).\n\n    Only works with 2-D Vectors.\n\n    Args:\n        v (array-like): 2-D vector.\n\n    Returns:\n        Vector: Perpendicular vector.\n\n    Raises:\n        ValueError: If v is not array-like or is not 2D\n    \"\"\"\n    validate_array_like(v, \"v\")\n    if len(v) != 2:\n        raise ValueError(\"vector_perp only works with 2D vectors\")\n    x, y = v\n    return Vector(-y, x)\n</code></pre>"},{"location":"#modsim.vector_polar","title":"<code>vector_polar(v)</code>","text":"<p>Vector magnitude and angle.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(magnitude, angle in radians).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v is not array-like</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_polar(v):\n    \"\"\"Vector magnitude and angle.\n\n    Args:\n        v (array-like): Vector.\n\n    Returns:\n        tuple: (magnitude, angle in radians).\n\n    Raises:\n        ValueError: If v is not array-like\n    \"\"\"\n    validate_array_like(v, \"v\")\n    return vector_mag(v), vector_angle(v)\n</code></pre>"},{"location":"#modsim.vector_proj","title":"<code>vector_proj(v, w)</code>","text":"<p>Projection of v onto w.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Vector to project.</p> required <code>w</code> <code>array - like</code> <p>Vector to project onto.</p> required <p>Returns:</p> Type Description <p>array-like: Projection of v onto w.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If v or w are not array-like or not same length</p> Source code in <code>modsim/modsim.py</code> <pre><code>def vector_proj(v, w):\n    \"\"\"Projection of v onto w.\n\n    Args:\n        v (array-like): Vector to project.\n        w (array-like): Vector to project onto.\n\n    Returns:\n        array-like: Projection of v onto w.\n\n    Raises:\n        ValueError: If v or w are not array-like or not same length\n    \"\"\"\n    validate_array_like(v, \"v\")\n    validate_array_like(w, \"w\")\n    if len(v) != len(w):\n        raise ValueError(\"Vectors must have the same length for projection\")\n    w_hat = vector_hat(w)\n    return vector_dot(v, w_hat) * w_hat\n</code></pre>"}]}